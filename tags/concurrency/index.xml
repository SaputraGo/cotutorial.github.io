<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>concurrency on My New Hugo Site</title>
    <link>http://example.org/tags/concurrency/</link>
    <description>Recent content in concurrency on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 05 Dec 2018 13:03:31 +0000</lastBuildDate>
    
	<atom:link href="http://example.org/tags/concurrency/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Python Maps Tutorial</title>
      <link>http://example.org/python/python-maps-tutorial/</link>
      <pubDate>Wed, 24 May 2017 07:57:51 +0100</pubDate>
      
      <guid>http://example.org/python/python-maps-tutorial/</guid>
      <description>This tutorial was built using Python 3.6
 Maps in Python are syntactic sugar that allow you to very succinctly iterate through every element of an array and perform a function on it.
Imagine we started off with a list of values numbering from 2-6 like so:
values = [2,3,4,5,6] And we had a function which doubled said values:
def double(x): return x * 2 Without the use of maps we would have to do something like so in order to multiply every element:</description>
    </item>
    
    <item>
      <title>Concurrency With Golang Goroutines</title>
      <link>http://example.org/golang/concurrency-with-golang-goroutines/</link>
      <pubDate>Sun, 09 Apr 2017 21:06:27 +0100</pubDate>
      
      <guid>http://example.org/golang/concurrency-with-golang-goroutines/</guid>
      <description>Now, Go is an incredibly performant language that features a hell of a lot of great features that allow you to build incredibly fast applications. It redefines what it means to build concurrent programs by providing us with these goroutines and channels.
Using goroutines is a very quick way to turn what would be a sequential program into a concurrent program without having to worry about things like creating threads or thread-pools.</description>
    </item>
    
    <item>
      <title>Go Mutex Tutorial</title>
      <link>http://example.org/golang/go-mutex-tutorial/</link>
      <pubDate>Sat, 25 Aug 2018 14:21:04 +0100</pubDate>
      
      <guid>http://example.org/golang/go-mutex-tutorial/</guid>
      <description>The use of Go when programming highly concurrent applications doesn&amp;rsquo;t preclude the possibility of you writing a system that features race conditions. These race conditions can cause unexpected issues with your systems that are both hard to debug and at times, even harder to fix.
Thus, we need to be able to write Go programs that can execute concurrently in a safe manner without impacting performance. This is where the mutex comes into play.</description>
    </item>
    
    <item>
      <title>Go Channels Tutorial</title>
      <link>http://example.org/golang/go-channels-tutorial/</link>
      <pubDate>Sat, 25 Aug 2018 14:47:06 +0100</pubDate>
      
      <guid>http://example.org/golang/go-channels-tutorial/</guid>
      <description>In this tutorial, we are going to be looking at how you can use channels within your Go-based applications.
Channels are pipes that link between goroutines within your Go based applications that allow communication and subsequently the passing of values to and from variables.
They are incredibly handy and can help you craft incredibly high performance, highly concurrent applications in Go with minimal fuss compared to other programming languages. This was by no means a fluke, when designing the language, the core developers decided that they wanted concurrency within their language to be a first class citizen and to make it as simple to work with as possible, without going too far and not allowing developers the freedom they need to work in.</description>
    </item>
    
    <item>
      <title>Go WaitGroup Tutorial</title>
      <link>http://example.org/golang/go-waitgroup-tutorial/</link>
      <pubDate>Wed, 05 Dec 2018 13:03:31 +0000</pubDate>
      
      <guid>http://example.org/golang/go-waitgroup-tutorial/</guid>
      <description>If you are just starting your journey about learning Go and how to implement highly concurrent, high-performance applications, then an understanding of WaitGroups is vital.
In this tutorial, we are going to be covering the following:
 What WaitGroups are and when we should use them A simple example of working with WaitGroups A real world example of WaitGroups  By the end of this, you should have a solid grasp as to how to employ WaitGroups within your own concurrent Go applications.</description>
    </item>
    
    <item>
      <title>Asyncio Semaphores and Bounded Semaphores Tutorial</title>
      <link>http://example.org/python/concurrency/python-asyncio-semaphores-tutorial/</link>
      <pubDate>Fri, 24 Nov 2017 13:39:00 +0000</pubDate>
      
      <guid>http://example.org/python/concurrency/python-asyncio-semaphores-tutorial/</guid>
      <description>This tutorial was built on top of Python 3.6.
 In this tutorial we&amp;rsquo;ll be looking at semaphores and bounded-semaphores and how they work within the Asyncio framework.
Video Tutorial  What Are Semaphores? Semaphores were originally a key part of railway system architecture and it was the famous Dijkstra that translated this real-world concept into our computing world.
These semaphores have an internal counter that is incremented and decremented whenever either an acquire or a release call is made.</description>
    </item>
    
    <item>
      <title>Asyncio Synchronization Primitives Tutorial - Queues and Locks</title>
      <link>http://example.org/python/concurrency/asyncio-synchronization-primitives-tutorial/</link>
      <pubDate>Thu, 23 Nov 2017 19:35:09 +0000</pubDate>
      
      <guid>http://example.org/python/concurrency/asyncio-synchronization-primitives-tutorial/</guid>
      <description>This tutorial was built on top of Python 3.6
 Video Tutorial  In this tutorial we&amp;rsquo;ll be looking at the various synchronization primitives available to you in your Asyncio programming adventures. We&amp;rsquo;ll be taking a brief look at why these synchronization primitives are important and also the various ways you can use them within a simple Asyncio based program.
Why Are These Important? When it comes to programming concurrent systems you have to try and ensure that your program is free from a little thing called a Race Condition.</description>
    </item>
    
    <item>
      <title>Asyncio Tasks Tutorial</title>
      <link>http://example.org/python/concurrency/asyncio-tasks-tutorial/</link>
      <pubDate>Sat, 11 Nov 2017 13:06:32 +0000</pubDate>
      
      <guid>http://example.org/python/concurrency/asyncio-tasks-tutorial/</guid>
      <description>This tutorial was built on top of Python 3.6
 In this tutorial we&amp;rsquo;ll be looking at Tasks in Asyncio. We&amp;rsquo;ll be building on top of my previous tutorial on Asyncio Event Loops.
Tasks Tasks within Asyncio are responsible for the execution of coroutines within an event loop. These tasks can only run in one event loop at one time and in order to achieve parallel execution you would have to run multiple event loops over multiple threads.</description>
    </item>
    
    <item>
      <title>Getting Started with Asyncio in Python</title>
      <link>http://example.org/python/concurrency/getting-started-with-asyncio-python/</link>
      <pubDate>Sat, 04 Nov 2017 15:20:50 +0000</pubDate>
      
      <guid>http://example.org/python/concurrency/getting-started-with-asyncio-python/</guid>
      <description>Video Tutorial   This tutorial was written on top of Python 3.6. This is taken from my book &amp;ldquo;Learning Concurrency in Python&amp;rdquo; if you wish to read up more on the library.
 Asyncio became part of the Python ecosystem in version 3.4 and has since then become the basis for a huge number of Python libraries and frameworks due to it&amp;rsquo;s impressive speed and ease of use. Asyncio allows you to easily write single-threaded concurrent programs that utilize something called coroutines, these coroutines are like a stripped down threads and don&amp;rsquo;t come with the same inherit performance issues that your full-fat threads would typically come with.</description>
    </item>
    
    <item>
      <title>Threads in Python</title>
      <link>http://example.org/python/concurrency/threads-in-python/</link>
      <pubDate>Tue, 31 Oct 2017 22:00:56 +0000</pubDate>
      
      <guid>http://example.org/python/concurrency/threads-in-python/</guid>
      <description>This tutorial was written using Python 3.6. Some of the code may not be compatible with Python 2.7
 In this tutorial we are going to take an in-depth look at threads in Python. We&amp;rsquo;ll start by covering what they consist of, we&amp;rsquo;ll then touch upon how you can define your own simple threads within your Python programs and finally we&amp;rsquo;ll cover all of the ways you can work with these simple threads within a simple Python program.</description>
    </item>
    
    <item>
      <title>Asyncio Event Loops Tutorial</title>
      <link>http://example.org/python/concurrency/asyncio-event-loops-tutorial/</link>
      <pubDate>Sat, 28 Oct 2017 11:50:27 +0100</pubDate>
      
      <guid>http://example.org/python/concurrency/asyncio-event-loops-tutorial/</guid>
      <description>This tutorial was built on top of Python 3.6.
 In this tutorial we are going to be covering Asyncio&amp;rsquo;s event loop. Some of the material for this tutorial was taken from my book: Learning Concurrency in Python.
Video  The Event Loop The main component of any asyncio based Python program has to be the underlying event loop. Within this event loop we can (from the official documentation):</description>
    </item>
    
    <item>
      <title>Python Event-Driven Programming with RxPY - Tutorial</title>
      <link>http://example.org/python/python-event-driven-rxpy-tutorial/</link>
      <pubDate>Sat, 14 Oct 2017 11:30:25 +0100</pubDate>
      
      <guid>http://example.org/python/python-event-driven-rxpy-tutorial/</guid>
      <description>This tutorial was built using Python 3.6
 The reactive programming paradigm is something that I&amp;rsquo;ve always been interested in upon learning about them when working with RxJS in my Angular 2+ based projects.
Event based systems can dynamically react to different situations in smart ways and the ReactiveX library enables to do this in a such a way that our code is succinct and easy to follow.</description>
    </item>
    
    <item>
      <title>Python ProcessPoolExecutor Tutorial</title>
      <link>http://example.org/python/concurrency/python-processpoolexecutor-tutorial/</link>
      <pubDate>Sun, 01 Oct 2017 13:52:59 +0100</pubDate>
      
      <guid>http://example.org/python/concurrency/python-processpoolexecutor-tutorial/</guid>
      <description>This tutorial has been taken and adapted from my book: Learning Concurrency in Python
 Video Tutorial  Introduction In this tutorial we will be looking at how you can utilize multiple processors within your Python Programs.
Multiprocessing vs Multithreading Knowing when and where to use multiple threads vs multiple processes is incredibly important if you are going to be working on highly performant Python programs. Misuse of either threads or processes could lead to your systems actually seeing performance degradation.</description>
    </item>
    
    <item>
      <title>Python ThreadPoolExecutor Tutorial</title>
      <link>http://example.org/python/concurrency/python-threadpoolexecutor-tutorial/</link>
      <pubDate>Sun, 01 Oct 2017 13:36:48 +0100</pubDate>
      
      <guid>http://example.org/python/concurrency/python-threadpoolexecutor-tutorial/</guid>
      <description>This tutorial has been taken and adapted from my book: Learning Concurrency in Python
 In this tutorial we&amp;rsquo;ll be looking at Python&amp;rsquo;s ThreadPoolExecutor. This was originally introduced into the language in version 3.2 and provides a simple high-level interface for asynchronously executing input/output bound tasks.
Why Use a ThreadPoolExecutor? ThreadPoolExecutors provide a simple abstraction around spinning up multiple threads and using these threads to perform tasks in a concurrent fashion.</description>
    </item>
    
    <item>
      <title>Python Multithreading Tutorial - Concurrent Programming</title>
      <link>http://example.org/python/python-multithreading-tutorial/</link>
      <pubDate>Sat, 15 Apr 2017 09:55:57 +0100</pubDate>
      
      <guid>http://example.org/python/python-multithreading-tutorial/</guid>
      <description>In this tutorial, we are going to be looking at how you you can use multithreading within your Python applications.
What is Multithreading? Modern computers tend to feature a CPU that has multiple processing cores, each of these cores can run many threads simultaneously which gives us the ability to perform several tasks concurrently. This tutorial will hopefully show you how to get started with Python&amp;rsquo;s threading module.
Objectives:</description>
    </item>
    
    <item>
      <title>Python Multiprocessing Tutorial</title>
      <link>http://example.org/python/python-multiprocessing-tutorial/</link>
      <pubDate>Sat, 15 Apr 2017 09:28:06 +0100</pubDate>
      
      <guid>http://example.org/python/python-multiprocessing-tutorial/</guid>
      <description>Last Updated: 1st December, 2018
 Introduction Previously we&amp;rsquo;ve looked at how you can try to achieve concurrency with Python using multithreading, the tutorial of which can be found here: Python Multithreading Tutorial
Now we are going to be having a look at how we can sidestep the limiting Global Interpreter Lock that effectively prevented our multithreaded applications from being truly concurrent by using the multiprocessing Python module.</description>
    </item>
    
  </channel>
</rss>